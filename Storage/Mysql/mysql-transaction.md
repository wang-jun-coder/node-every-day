### 事务

事务指的是一系列强关联的逻辑操作，若成功，则全部失败，若失败则全部撤销

#### 参考资料
* [常用的分布式事务解决方案](https://juejin.im/post/5aa3c7736fb9a028bb189bca)

#### 事务的特点 ACID
* 原子性，事务操作不可分割，若成功全部成功，若失败全部回滚
* 一致性，事务的执行，不影响数据的完整性
* 隔离性，事务并发执行时，互相隔离，互不干扰
* 持久性，事务执行完成，对数据的操作是永久的

#### 事务并发导致的问题

* 丢失更新
	* 事务回滚，导致丢失更新 	 
		* 事务 a 和事务 b 分别读取初始状态，如：余额： 100
		* 事务 b 执行扣款操作并成功，如：余额：95
		* 事务 a 由于某些操作，导致操作失败，数据回滚，余额：100
		* 于是事务 b 的更新丢失
	* 事务覆盖，导致丢失更新
		* 事务 a 和事务 b 分别读取初始状态，如：余额： 100
		* 事务 b 执行扣款5元操作并成功，如：余额：95
		* 事务 a 执行扣款10元操作并成功，如：余额：90
		* 于是事务 b 的更新丢失
	
* 脏读（读未提交）
	* 事务 a 读取初始状态， 如：余额：100
	* 事务 a 执行扣款操作但尚未提交, 如：未提交：余额： 10
	* 事务 b 读取到了事务 a 未提交的值，余额： 10
	* 事务 b 不满足条件，操作失败，未进行任何修改
	* 事务 a 由于某些操作，也操作失败，未提交的数据也被回滚，余额： 100
	* 此时事务 b 就是脏读，由于读取了不正确的值导致事务失败
* 幻读（虚读）  
	一个事务执行两次查询，第二次查询包含第一次中没有或已删除的数据，造成两次结果不一致
	* 事务 a 执行一个操作，将表中所以有行的 C 列值为 1 的，统一改为 2
	* 事务 a 执行过程中，事务 b 向表中插入一条 C 列值为 1 的记录
	* 事务 a 再次查看表中数据，发现仍有一条记录尚未修改
	* 此时产生幻读

* 不可重复读  
	一个事务两次读取同一行的数据，得到不同状态的结果。
	* 事务 a 读取某行数据，如：余额：100
	* 事务 b 更新并提交数据，如： 余额： 101
	* 事务 a 再次读取该行数据，如：余额：101
	* 此时事务 a 产生不可重复读  

##### 注意
* 不可重复读 vs 脏读： 脏读是由于读未提交的脏数据，不可重复读，则是读取了事务提交数据（有效数据） 
* 幻读 vs 不可重复读：均是读取事务提交数据（有效数据），但是幻读表示的是一组数据集体，不可重复读表示的是单条数据


#### 事务的隔离性
* 读未提交  
	最低隔离级别，无法保证任何问题，易产生脏读
* 读提交  
	读取仅可以读取已提交的数据，未提交数据不可见，可解决脏读问题，但不能解决不可重复读的问题，如：
	* 事务 a 需执行扣款 100 元操作，此时查询 余额：100
	* 事务 b 执行扣款 10 元并成功提交，此时余额：90
	* 事务 a 扣款前再次检查，余额不足，操作失败

* 可重复读
	当事务开启后，不允许修改数据，直至事务结束。可解决脏读，不可重复读问题，一般数据库默认隔离级别为 可重复读 
* 串行化
	此级别下，所有事务串行执行，可解决脏读，不可重复读，幻读等问题，但效率角度
	
	
#### 本地事务如何实现
* 事务开启后，记录 redo 日志
* 获取数据，记录 undo 日志
* 执行事务内容
* 若失败，执行 undo 日志操作
* 结束事务  

#### 分布式事务
分布式事务，指的是事务参与者，处于分布式系统的不同结点上

##### CAP 定理
* 一致性（Consistency）：向结点 a 发起修改请求，成功后向结点 b 发起请求可以获得最新值
* 可用性（Availability）：只要收到请求，服务器必须给出回应
* 分区容错性（Partition tolerance）：分区之间的通信可能失败

一般来说，分区容错无法避免，可认为 P 总是成立，剩下的 C A 无法同时做到，这是由于分区容错的问题导致的，若要保证一致性，必须等待分区通信成功，此时无法保证可用性，若要保证可用性，则需要放弃等待分区通信成功

##### BASE
* 基本可用（Basically Available） 
* 软状态（Soft State）
* 最终一致性（Eventually Consistent）

核心思想是，既然无法做到强一致性，则可通过适当手段达成最终一致性

##### 分布式事务的协议
* 两阶段提交协议 2PC  
	缺陷： 没有超时机制。协调者发布部分提交后宕机，导致事务异常。
	* 投票阶段
		* 协调者询问各结点是否可提交
		* 参与者记录 undo redo 日志，并执行事务操作
		* 各参与者根据执行结果，返回同意还是终止
	* 提交执行阶段
		* 若投票阶段有任一参与者返回终止，则此阶段协调各参与者执行回滚操作，完成事务
		* 若投票均同意，此阶段执行提交操作，各参与者执行完成并返回，完成事务  
* 三阶段提交协议 3PC  
 引入超时机制，插入准备阶段
	* CanCommit
		* 询问各个节点是否可参与事务
	* PreCommit
		* 发送预提交请求，各参与者记录事务 undo redo 日志，并返回结果
		* 若有参与者返回失败或超时，则终止事务，进行回滚
	* doCommit 
		* 协调者发送提交请求，参与者执行事务正式提交
		* 若有参与者执行失败，则回滚事务
		
##### 分布式事务的解决方案
* 全局事务（DTP模型/Distributed Transaction Processing Reference Model）
* 基于可靠消息服务的分布式事务
	* 系统 a 向消息中间件，发送消息
	* 消息持久化后应答系统 a 
	* 系统 a 开始执行事务，执行成功后，发送commit 消息给消息中间件
	* 消息中间件推送消息，到系统 b
	* 系统 b 执行事务，成功向消息中间件发送确认应答
* 最大努力通知（定期校对）
	* 通过消息中间件，对失败的消息多次尝试通知
* TCC（两阶段型、补偿型/Try Confirm Cancel）
	* Try：尝试待执行的业务, 并预留资源，如准备 a -> b 转账 100， 此处进行检查，并扣除 a 账户 100
	* Confirm：执行业务， 向 b 账户增加 100
	* Cancel：取消执行的业务，try 或 confirm 出现任何异常，则回滚事务，进入此阶段，如，将 a 账户扣除的余额再加上

	





