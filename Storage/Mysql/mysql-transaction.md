### 事务

事务指的是一系列强关联的逻辑操作，若成功，则全部失败，若失败则全部撤销

#### 事务的特点 ACID
* 原子性，事务操作不可分割，若成功全部成功，若失败全部回滚
* 一致性，事务的执行，不影响数据的完整性
* 隔离性，事务并发执行时，互相隔离，互不干扰
* 持久性，事务执行完成，对数据的操作是永久的

#### 事务并发导致的问题

* 丢失更新
	* 事务回滚，导致丢失更新 	 
		* 事务 a 和事务 b 分别读取初始状态，如：余额： 100
		* 事务 b 执行扣款操作并成功，如：余额：95
		* 事务 a 由于某些操作，导致操作失败，数据回滚，余额：100
		* 于是事务 b 的更新丢失
	* 事务覆盖，导致丢失更新
		* 事务 a 和事务 b 分别读取初始状态，如：余额： 100
		* 事务 b 执行扣款5元操作并成功，如：余额：95
		* 事务 a 执行扣款10元操作并成功，如：余额：90
		* 于是事务 b 的更新丢失
	
* 脏读（读未提交）
	* 事务 a 读取初始状态， 如：余额：100
	* 事务 a 执行扣款操作但尚未提交, 如：未提交：余额： 10
	* 事务 b 读取到了事务 a 未提交的值，余额： 10
	* 事务 b 不满足条件，操作失败，未进行任何修改
	* 事务 a 由于某些操作，也操作失败，未提交的数据也被回滚，余额： 100
	* 此时事务 b 就是脏读，由于读取了不正确的值导致事务失败
* 幻读（虚读）  
	一个事务执行两次查询，第二次查询包含第一次中没有或已删除的数据，造成两次结果不一致
	* 事务 a 执行一个操作，将表中所以有行的 C 列值为 1 的，统一改为 2
	* 事务 a 执行过程中，事务 b 向表中插入一条 C 列值为 1 的记录
	* 事务 a 再次查看表中数据，发现仍有一条记录尚未修改
	* 此时产生幻读

* 不可重复读  
	一个事务两次读取同一行的数据，得到不同状态的结果。
	* 事务 a 读取某行数据，如：余额：100
	* 事务 b 更新并提交数据，如： 余额： 101
	* 事务 a 再次读取该行数据，如：余额：101
	* 此时事务 a 产生不可重复读  

##### 注意
* 不可重复读 vs 脏读： 脏读是由于读未提交的脏数据，不可重复读，则是读取了事务提交数据（有效数据） 
* 幻读 vs 不可重复读：均是读取事务提交数据（有效数据），但是幻读表示的是一组数据集体，不可重复读表示的是单条数据


#### 事务的隔离性
* 读未提交  
	最低隔离级别，无法保证任何问题，易产生脏读
* 读提交  
	读取仅可以读取已提交的数据，未提交数据不可见，可解决脏读问题，但不能解决不可重复读的问题，如：
	* 事务 a 需执行扣款 100 元操作，此时查询 余额：100
	* 事务 b 执行扣款 10 元并成功提交，此时余额：90
	* 事务 a 扣款前再次检查，余额不足，操作失败

* 可重复读
	当事务开启后，不允许修改数据，直至事务结束。可解决脏读，不可重复读问题，一般数据库默认隔离级别为 可重复读 
* 串行化
	此级别下，所有事务串行执行，可解决脏读，不可重复读，幻读等问题，但效率角度
	
	
#### 本地事务如何实现
* 事务开启后，记录 redo 日志
* 获取数据，记录 undo 日志
* 执行事务内容
* 若失败，执行 undo 日志操作
* 结束事务  

#### 分布式事务
分布式事务，指的是事务参与者，处于分布式系统的不同结点上

##### CAP 定理
* 一致性（Consistency）：向结点 a 发起修改请求，成功后向结点 b 发起请求可以获得最新值
* 可用性（Availability）：只要收到请求，服务器必须给出回应
* 分区容错性（Partition tolerance）：分区之间的通信可能失败

一般来说，分区容错无法避免，可认为 P 总是成立，剩下的 C A 无法同时做到，这是由于分区容错的问题导致的，若要保证一致性，必须等待分区通信成功，此时无法保证可用性，若要保证可用性，则需要放弃等待分区通信成功

##### BASE
* 基本可用（Basically Available） 
* 软状态（Soft State）
* 最终一致性（Eventually Consistent）

核心思想是，既然无法做到强一致性，则可通过适当手段达成最终一致性

##### 分布式事务的解决方案




